#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>
#include <allegro5/allegro_image.h>
#include <fstream>
#include <iostream>
#include <vector>
#include <cstdlib>

const int SCREEN_WIDTH = 800;
const int SCREEN_HEIGHT = 600;

const int SQUARE_SIZE = 50;
const int SQUARE_SPEED = 5;

const int MAP_WIDTH = 16;
const int MAP_HEIGHT = 12;

int square_x;
int square_y;

bool key_left = false;
bool key_right = false;

int map[MAP_HEIGHT][MAP_WIDTH];

ALLEGRO_BITMAP* block_image;
ALLEGRO_BITMAP* background_image;

struct FallingObject {
    float x;
    float y;
    float radius;
};

std::vector<FallingObject> fallingObjects;

void LoadMap(const char* filename) {
    std::ifstream file(filename);
    if (!file) {
        std::cout << "Error al abrir el archivo: " << filename << std::endl;
        return;
    }

    for (int y = 0; y < MAP_HEIGHT; ++y) {
        for (int x = 0; x < MAP_WIDTH; ++x) {
            file >> map[y][x];
        }
    }

    file.close();
}

void LoadBlockImage() {
    block_image = al_load_bitmap("bloque.png");
    if (!block_image) {
        std::cout << "Error al cargar la imagen del bloque." << std::endl;
    }
}

void LoadBackgroundImage() {
    background_image = al_load_bitmap("wallpaper.png");
    if (!background_image) {
        std::cout << "Error al cargar la imagen de fondo." << std::endl;
    }
}

void UpdateSquarePosition() {
    int new_x = square_x;
    int new_y = square_y;

    if (key_left) {
        new_x = square_x - SQUARE_SPEED;
        int left_x = new_x;
        int top_left_y = square_y;
        int bottom_left_y = square_y + SQUARE_SIZE - 1;

        if (new_x >= 0 && map[top_left_y / SQUARE_SIZE][left_x / SQUARE_SIZE] == 0 && map[bottom_left_y / SQUARE_SIZE][left_x / SQUARE_SIZE] == 0) {
            square_x = new_x;
        }
    }
    if (key_right) {
        new_x = square_x + SQUARE_SPEED;
        int right_x = new_x + SQUARE_SIZE - 1;
        int top_right_y = square_y;
        int bottom_right_y = square_y + SQUARE_SIZE - 1;

        if (new_x + SQUARE_SIZE <= SCREEN_WIDTH && map[top_right_y / SQUARE_SIZE][right_x / SQUARE_SIZE] == 0 && map[bottom_right_y / SQUARE_SIZE][right_x / SQUARE_SIZE] == 0) {
            square_x = new_x;
        }
    }
}

int main() {
    int x, y;
    bool running;
    al_init();
    al_init_primitives_addon();
    al_init_image_addon();
    al_install_keyboard();

    ALLEGRO_DISPLAY* display = al_create_display(SCREEN_WIDTH, SCREEN_HEIGHT);
    ALLEGRO_EVENT_QUEUE* event_queue = al_create_event_queue();
    al_register_event_source(event_queue, al_get_display_event_source(display));
    al_register_event_source(event_queue, al_get_keyboard_event_source());

    LoadMap("mapa.txt");
    LoadBlockImage();
    LoadBackgroundImage();

    square_x = 0;
    square_y = SCREEN_HEIGHT - SQUARE_SIZE;

    running = true;

    al_draw_scaled_bitmap(background_image, 0, 0, al_get_bitmap_width(background_image), al_get_bitmap_height(background_image),
        0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0);

    for (y = 0; y < MAP_HEIGHT; ++y) {
        for (x = 0; x < MAP_WIDTH; ++x) {
            if (map[y][x] == 1) {
                al_draw_scaled_bitmap(block_image, 0, 0, al_get_bitmap_width(block_image), al_get_bitmap_height(block_image),
                    x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE, 0);
            }
        }
    }

    al_draw_filled_rectangle(square_x, square_y, square_x + SQUARE_SIZE, square_y + SQUARE_SIZE, al_map_rgb(255, 255, 255));
    al_flip_display();

    srand(time(NULL));

    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60);
    al_register_event_source(event_queue, al_get_timer_event_source(timer));
    al_start_timer(timer);

    int fallingObjectSpeed = 2;
    int newObjectFrequency = 100;

    while (running) {
        ALLEGRO_EVENT event;
        al_wait_for_event(event_queue, &event);

        if (event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
            running = false;
        }
        else if (event.type == ALLEGRO_EVENT_KEY_DOWN) {
            switch (event.keyboard.keycode) {
            case ALLEGRO_KEY_LEFT:
                key_left = true;
                break;
            case ALLEGRO_KEY_RIGHT:
                key_right = true;
                break;
            }
        }
        else if (event.type == ALLEGRO_EVENT_KEY_UP) {
            switch (event.keyboard.keycode) {
            case ALLEGRO_KEY_LEFT:
                key_left = false;
                break;
            case ALLEGRO_KEY_RIGHT:
                key_right = false;
                break;
            }
        }
        else if (event.type == ALLEGRO_EVENT_TIMER) {
            UpdateSquarePosition();

            for (auto& obj : fallingObjects) {
                obj.y += fallingObjectSpeed;

                if (obj.y + obj.radius >= square_y && obj.x + obj.radius >= square_x && obj.x - obj.radius <= square_x + SQUARE_SIZE) {
                    obj.y = -obj.radius;
                }
            }

            fallingObjects.erase(std::remove_if(fallingObjects.begin(), fallingObjects.end(),
                [](const FallingObject& obj) { return obj.y - obj.radius > SCREEN_HEIGHT; }), fallingObjects.end());

            if (rand() % newObjectFrequency == 0) {
                FallingObject newObj;
                newObj.x = rand() % (SCREEN_WIDTH - SQUARE_SIZE) + SQUARE_SIZE / 2;
                newObj.y = -SQUARE_SIZE / 2;
                newObj.radius = SQUARE_SIZE / 2;
                fallingObjects.push_back(newObj);
            }

            al_draw_scaled_bitmap(background_image, 0, 0, al_get_bitmap_width(background_image), al_get_bitmap_height(background_image),
                0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0);

            for (y = 0; y < MAP_HEIGHT; ++y) {
                for (x = 0; x < MAP_WIDTH; ++x) {
                    if (map[y][x] == 1) {
                        al_draw_scaled_bitmap(block_image, 0, 0, al_get_bitmap_width(block_image), al_get_bitmap_height(block_image),
                            x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE, 0);
                    }
                }
            }

            for (const auto& obj : fallingObjects) {
                al_draw_filled_circle(obj.x, obj.y, obj.radius, al_map_rgb(255, 0, 0));
            }

            al_draw_filled_rectangle(square_x, square_y, square_x + SQUARE_SIZE, square_y + SQUARE_SIZE, al_map_rgb(255, 255, 255));
            al_flip_display();
        }
    }

    al_destroy_display(display);
    al_destroy_event_queue(event_queue);
    al_destroy_bitmap(block_image);
    al_destroy_bitmap(background_image);
    al_destroy_timer(timer);

    return 0;
}